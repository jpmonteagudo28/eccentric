length(dots) < 1
length(dots) == 0
length(dots) < 1
if(is_empty(dots) && !is.null(dots) && !(is.character(dots) || is.logical(dots))){
message("Default location and scale parameters will be used unless specified as extra arguments
in the function")
} else if(is.character(dots) || is.logical(dots)){
stop("Optional arguments must be numeric, not of class character or logical")
} else if(is.null(dots)){
stop("Optional arguments cannot be null")
} else {
message("Extra arguments will be passed to inverse function specified")
}
is_empty <- function(x){
(length(x) == 0L)
}
if(is_empty(dots) && !is.null(dots) && !(is.character(dots) || is.logical(dots))){
message("Default location and scale parameters will be used unless specified as extra arguments
in the function")
} else if(is.character(dots) || is.logical(dots)){
stop("Optional arguments must be numeric, not of class character or logical")
} else if(is.null(dots)){
stop("Optional arguments cannot be null")
} else {
message("Extra arguments will be passed to inverse function specified")
}
deparse("rbeta")
eval(deparse("rbeta"))
deparse_dots <- function(...) {
vapply(substitute(...()), deparse, NA_character_)
}
deparse_dots("rbeta")
deparse_dots(rbeta)
get('rbeta')
inverse <- "rbeta"
# Use get() to retrieve the function and pass arguments
random_data <- get(inverse)(n = 100, shape1 = 2, shape2 = 5)
# View the random data
head(random_data)
?scale
?sample
simulate_clt <- function(n = NULL,
inverse = NULL,
samples = 249,
...){
stopifnot(is.null(n),
is.null(inverse) || is.character(inverse),
is.null(samples) || is.numeric(samples)
)
if(min(n) <= 1 || !is.numeric(n) || is.atomic(n)){
stop("n must be an atomic vector of integers greater than 1")
}
# Capture extra arguments passed to inverse
dots <- list(...)
# Check if dots are empty or of an invalid class
if(is_empty(dots) && !is.null(dots) && !(is.character(dots) || is.logical(dots))){
message("Default location and scale parameters will be used unless specified as extra arguments
in the function")
} else if(is.character(dots) || is.logical(dots)){
stop("Optional arguments must be numeric, not of class character or logical")
} else if(is.null(dots)){
stop("Optional arguments cannot be null")
} else {
message("Extra arguments will be passed to inverse function specified")
}
# What values can the inverse arg take?
inverse <- match.arg(inverse,
choices = c(
'rbeta','rbinom','rcauchy'
,'rchisq','rexp','rf'
,'rgamma','rgeom','rhyper'
,'rlnorm','rmultinorm','rnbinom'
,'rnorm','rpois','rt'
,'runif','rweibull','rsignrank'
,'rwilcox','rlogis'
),
several.ok = FALSE
)
# Set up vector of values for inverse function
randomly_gen_data <- if (!is.null(dots) && !is_empty(dots)) {
do.call(get(inverse), c(list(n = n), dots))
} else {
get(inverse)(n = n)
}
# Standardize vector of values for inverse function
centered_random_data <- scale(randomly_gen_data)
# Resample with replacement from vector of values for inverse
resampled_data <- sample(
centered_random_data,
size = samples,
replace = TRUE
)
return(resampled_data)
}
simulate_clt(n = 100,inverse = "rcauchy")
simulate_clt <- function(n = NULL,
inverse = NULL,
samples = 249,
...){
stopifnot(is.numeric(n),
is.null(inverse) || is.character(inverse),
is.null(samples) || is.numeric(samples)
)
if(min(n) <= 1 || !is.numeric(n) || is.atomic(n)){
stop("n must be an atomic vector of integers greater than 1")
}
# Capture extra arguments passed to inverse
dots <- list(...)
# Check if dots are empty or of an invalid class
if(is_empty(dots) && !is.null(dots) && !(is.character(dots) || is.logical(dots))){
message("Default location and scale parameters will be used unless specified as extra arguments
in the function")
} else if(is.character(dots) || is.logical(dots)){
stop("Optional arguments must be numeric, not of class character or logical")
} else if(is.null(dots)){
stop("Optional arguments cannot be null")
} else {
message("Extra arguments will be passed to inverse function specified")
}
# What values can the inverse arg take?
inverse <- match.arg(inverse,
choices = c(
'rbeta','rbinom','rcauchy'
,'rchisq','rexp','rf'
,'rgamma','rgeom','rhyper'
,'rlnorm','rmultinorm','rnbinom'
,'rnorm','rpois','rt'
,'runif','rweibull','rsignrank'
,'rwilcox','rlogis'
),
several.ok = FALSE
)
# Set up vector of values for inverse function
randomly_gen_data <- if (!is.null(dots) && !is_empty(dots)) {
do.call(get(inverse), c(list(n = n), dots))
} else {
get(inverse)(n = n)
}
# Standardize vector of values for inverse function
centered_random_data <- scale(randomly_gen_data)
# Resample with replacement from vector of values for inverse
resampled_data <- sample(
centered_random_data,
size = samples,
replace = TRUE
)
return(resampled_data)
}
simulate_clt(n = 100,inverse = "rcauchy")
?replicate
simulate_clt <- function(n = NULL,
inverse = NULL,
samples = 249,
...){
stopifnot(is.numeric(n),
is.null(inverse) || is.character(inverse),
is.null(samples) || is.numeric(samples)
)
if(min(n) <= 1 || !is.numeric(n) || is.atomic(n)){
stop("n must be an atomic vector of integers greater than 1")
}
# Capture extra arguments passed to inverse
dots <- list(...)
# Check if dots are empty or of an invalid class
if(is_empty(dots) && !is.null(dots) && !(is.character(dots) || is.logical(dots))){
message("Default location and scale parameters will be used unless specified as extra arguments
in the function")
} else if(is.character(dots) || is.logical(dots)){
stop("Optional arguments must be numeric, not of class character or logical")
} else if(is.null(dots)){
stop("Optional arguments cannot be null")
} else {
message("Extra arguments will be passed to inverse function specified")
}
# What values can the inverse arg take?
inverse <- match.arg(inverse,
choices = c(
'rbeta','rbinom','rcauchy'
,'rchisq','rexp','rf'
,'rgamma','rgeom','rhyper'
,'rlnorm','rmultinorm','rnbinom'
,'rnorm','rpois','rt'
,'runif','rweibull','rsignrank'
,'rwilcox','rlogis'
),
several.ok = FALSE
)
# Set up vector of values for inverse function
randomly_gen_data <- if (!is.null(dots) && is_empty(dots)) {
data_list <- lapply(n, function(size) {
do.call(get(inverse), c(list(n = size), dots))
})
} else {
data_list <- lapply(n, function(size) {
get(inverse)(n = size)
})
}
randomly_gen_data <- lapply(data_list, apply_na_padding, n)
# Combine padded data into a matrix
randomly_gen_data_matrix <- do.call(cbind, randomly_gen_data)
# Standardize vector of values for inverse function
centered_random_data <- scale(randomly_gen_data_matrix)
# Resample with replacement from vector of values for inverse
resampled_data <- replicate(n,
sample(
centered_random_data,
size = samples,
replace = TRUE
)
)
return(resampled_data)
}
simulate_clt(n = c(10,50,100),inverse = "rcauchy")
simulate_clt <- function(n = NULL,
inverse = NULL,
samples = 249,
...){
stopifnot(is.numeric(n),
is.null(inverse) || is.character(inverse),
is.null(samples) || is.numeric(samples)
)
if(min(n) <= 1 || !is.numeric(n) || !is.atomic(n)){
stop("n must be an atomic vector of integers greater than 1")
}
# Capture extra arguments passed to inverse
dots <- list(...)
# Check if dots are empty or of an invalid class
if(is_empty(dots) && !is.null(dots) && !(is.character(dots) || is.logical(dots))){
message("Default location and scale parameters will be used unless specified as extra arguments
in the function")
} else if(is.character(dots) || is.logical(dots)){
stop("Optional arguments must be numeric, not of class character or logical")
} else if(is.null(dots)){
stop("Optional arguments cannot be null")
} else {
message("Extra arguments will be passed to inverse function specified")
}
# What values can the inverse arg take?
inverse <- match.arg(inverse,
choices = c(
'rbeta','rbinom','rcauchy'
,'rchisq','rexp','rf'
,'rgamma','rgeom','rhyper'
,'rlnorm','rmultinorm','rnbinom'
,'rnorm','rpois','rt'
,'runif','rweibull','rsignrank'
,'rwilcox','rlogis'
),
several.ok = FALSE
)
# Set up vector of values for inverse function
randomly_gen_data <- if (!is.null(dots) && is_empty(dots)) {
data_list <- lapply(n, function(size) {
do.call(get(inverse), c(list(n = size), dots))
})
} else {
data_list <- lapply(n, function(size) {
get(inverse)(n = size)
})
}
randomly_gen_data <- lapply(data_list, apply_na_padding, n)
# Combine padded data into a matrix
randomly_gen_data_matrix <- do.call(cbind, randomly_gen_data)
# Standardize vector of values for inverse function
centered_random_data <- scale(randomly_gen_data_matrix)
# Resample with replacement from vector of values for inverse
resampled_data <- replicate(n,
sample(
centered_random_data,
size = samples,
replace = TRUE
)
)
return(resampled_data)
}
simulate_clt(n = c(10,50,100),inverse = "rcauchy")
apply_na_padding <- function(data,n){
max_len <- max(n)
length(data) <- max_len
return(data)
}
simulate_clt(n = c(10,50,100),inverse = "rcauchy")
dots <- length(0)
is.null(dots)
simulate_clt <- function(n = NULL,
inverse = NULL,
samples = 249,
...){
stopifnot(is.numeric(n),
is.null(inverse) || is.character(inverse),
is.null(samples) || is.numeric(samples)
)
if(min(n) <= 1 || !is.numeric(n) || !is.atomic(n)){
stop("n must be an atomic vector of integers greater than 1")
}
# Capture extra arguments passed to inverse
dots <- list(...)
# Check if dots are empty or of an invalid class
if(is_empty(dots) && !is.null(dots) && !(is.character(dots) || is.logical(dots))){
message("Default location and scale parameters will be used unless specified as extra arguments
in the function")
} else if(is.character(dots) || is.logical(dots)){
stop("Optional arguments must be numeric, not of class character or logical")
} else if(is.null(dots)){
stop("Optional arguments cannot be null")
} else {
message("Extra arguments will be passed to inverse function specified")
}
# What values can the inverse arg take?
inverse <- match.arg(inverse,
choices = c(
'rbeta','rbinom','rcauchy'
,'rchisq','rexp','rf'
,'rgamma','rgeom','rhyper'
,'rlnorm','rmultinorm','rnbinom'
,'rnorm','rpois','rt'
,'runif','rweibull','rsignrank'
,'rwilcox','rlogis'
),
several.ok = FALSE
)
# Set up vector of values for inverse function
randomly_gen_data <- if (!is_empty(dots)) {
data_list <- lapply(n, function(size) {
do.call(get(inverse), c(list(n = size), dots))
})
} else {
data_list <- lapply(n, function(size) {
get(inverse)(n = size)
})
}
randomly_gen_data <- lapply(randomly_gen_data, apply_na_padding, n)
# Combine padded data into a matrix
randomly_gen_data_matrix <- do.call(cbind, randomly_gen_data)
# Standardize vector of values for inverse function
centered_random_data <- scale(randomly_gen_data_matrix)
# Resample with replacement from vector of values for inverse
resampled_data <- replicate(n,
sample(
centered_random_data,
size = samples,
replace = TRUE
)
)
return(resampled_data)
}
simulate_clt(n = c(10,50,100),inverse = "rcauchy")
# Resample with replacement from vector of values for inverse
resampled_data <- replicate(1:length(n),
function(i) {
sample(
centered_random_data,
size = samples,
replace = TRUE
)
}
)
simulate_clt(n = c(10,50,100),inverse = "rcauchy")
simulate_clt <- function(n = NULL,
inverse = NULL,
samples = 249,
...){
stopifnot(is.numeric(n),
is.null(inverse) || is.character(inverse),
is.null(samples) || is.numeric(samples)
)
if(min(n) <= 1 || !is.numeric(n) || !is.atomic(n)){
stop("n must be an atomic vector of integers greater than 1")
}
# Capture extra arguments passed to inverse
dots <- list(...)
# Check if dots are empty or of an invalid class
if(is_empty(dots) && !is.null(dots) && !(is.character(dots) || is.logical(dots))){
message("Default location and scale parameters will be used unless specified as extra arguments
in the function")
} else if(is.character(dots) || is.logical(dots)){
stop("Optional arguments must be numeric, not of class character or logical")
} else if(is.null(dots)){
stop("Optional arguments cannot be null")
} else {
message("Extra arguments will be passed to inverse function specified")
}
# What values can the inverse arg take?
inverse <- match.arg(inverse,
choices = c(
'rbeta','rbinom','rcauchy'
,'rchisq','rexp','rf'
,'rgamma','rgeom','rhyper'
,'rlnorm','rmultinorm','rnbinom'
,'rnorm','rpois','rt'
,'runif','rweibull','rsignrank'
,'rwilcox','rlogis'
),
several.ok = FALSE
)
# Set up vector of values for inverse function
randomly_gen_data <- if (!is_empty(dots)) {
data_list <- lapply(n, function(size) {
do.call(get(inverse), c(list(n = size), dots))
})
} else {
data_list <- lapply(n, function(size) {
get(inverse)(n = size)
})
}
randomly_gen_data <- lapply(randomly_gen_data, apply_na_padding, n)
# Combine padded data into a matrix
randomly_gen_data_matrix <- do.call(cbind, randomly_gen_data)
# Standardize vector of values for inverse function
centered_random_data <- scale(randomly_gen_data_matrix)
# Resample with replacement from vector of values for inverse
resampled_data <- lapply(1:length(n),
function(i) {
sample(
centered_random_data,
size = samples,
replace = TRUE
)
}
)
return(resampled_data)
}
simulate_clt(n = c(10,50,100),inverse = "rcauchy")
simulate_clt <- function(n = NULL,
inverse = NULL,
samples = 249,
...){
stopifnot(is.numeric(n),
is.null(inverse) || is.character(inverse),
is.null(samples) || is.numeric(samples)
)
if(min(n) <= 1 || !is.numeric(n) || !is.atomic(n)){
stop("n must be an atomic vector of integers greater than 1")
}
# Capture extra arguments passed to inverse
dots <- list(...)
# Check if dots are empty or of an invalid class
if(is_empty(dots) && !is.null(dots) && !(is.character(dots) || is.logical(dots))){
message("Default location and scale parameters will be used unless specified as extra arguments
in the function")
} else if(is.character(dots) || is.logical(dots)){
stop("Optional arguments must be numeric, not of class character or logical")
} else if(is.null(dots)){
stop("Optional arguments cannot be null")
} else {
message("Extra arguments will be passed to inverse function specified")
}
# What values can the inverse arg take?
inverse <- match.arg(inverse,
choices = c(
'rbeta','rbinom','rcauchy'
,'rchisq','rexp','rf'
,'rgamma','rgeom','rhyper'
,'rlnorm','rmultinorm','rnbinom'
,'rnorm','rpois','rt'
,'runif','rweibull','rsignrank'
,'rwilcox','rlogis'
),
several.ok = FALSE
)
# Set up vector of values for inverse function
randomly_gen_data <- if (!is_empty(dots)) {
data_list <- lapply(n, function(size) {
do.call(get(inverse), c(list(n = size), dots))
})
} else {
data_list <- lapply(n, function(size) {
get(inverse)(n = size)
})
}
randomly_gen_data <- lapply(randomly_gen_data, apply_na_padding, n)
# Combine padded data into a matrix
randomly_gen_data_matrix <- do.call(cbind, randomly_gen_data)
# Standardize vector of values for inverse function
centered_random_data <- scale(randomly_gen_data_matrix)
# Resample with replacement from vector of values for inverse
resampled_data <- lapply(1:length(n),
function(i) {
sample(
centered_random_data,
size = samples,
replace = TRUE
)
}
)
resampled_data_df <- data.frame(resampled_data)
colnames(resampled_data_df) <- as.character(n)
return(resampled_data_df)
}
simulate_clt(n = c(10,50,100),inverse = "rcauchy")
test <- simulate_clt(n = c(10,50,100),inverse = "rcauchy")
View(test)
clt <- function(N = NULL, invcdf = NULL, B = 1000, mu = 0) {
if (!is.character(invcdf)) {
stop("invcdf must be a string expression for the formula of an inverse cdf")
}
if (min(N) <= 1 || !is.numeric(N) || !is.atomic(N)) {
stop("N must be an atomic vector containing only integers greater than 1")
}
clt.df <- data.frame(matrix(NA, B, length(N)))
for (n in N) {
for (i in 1:B) {
clt.sample <- eval(parse(text = invcdf))
clt.df[i, match(n, N)] <- (mean(clt.sample) - mu) / (sd(clt.sample) / sqrt(n))
}
}
colnames(clt.df) <- N
return(clt.df)
}
clt(N = c(10,50,100),invcdf = "runif(n,-1,1)")
clt(N = c(10,50,100),invcdf = "runif(n,-1,1)") -> test2
View(test2)
